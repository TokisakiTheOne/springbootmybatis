1.String的是怎样实现的？有哪些重要的方法？

标准的回答：(JDK1.8)
String内部实际存储结构为char数组
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    //用于存储字符串的值
    private final char value[];
    //缓存字符串的 hashcode
    private int hash; // Default to 0。

}





      1.构造方法   4个重要的构造方法
          //String参数的构造
          public String(String original) {
              this.value = original.value;
              this.hash = original.hash;
          }

          //char[]参数的构造
          public String(char value[]) {
              this.value = Arrays.copyOf(value, value.length);
          }
          //StringBuffer
          public String(StringBuffer sb){
            synchronized(sb){
              this.value=Arrays.copyOf(sb.getValue,sb.length());
            }
          }
           //StringBuilder
           public String(StringBuilder sb){
               synchronized(sb){
                this.value=Arrays.copyOf(sb.getValue,sb.length());
            }
          }
       2. equals() 比较字符串是否相等
         public boolean equals(Object anObject) {
                //对象引用相同直接返回true
               if (this == anObject) {
                   return true;
               }
               // 判断对比的值是否为String类型，不是直接返回false
               if (anObject instanceof String) {
                   String anotherString = (String)anObject;
                   int n = value.length;
                   if (n == anotherString.value.length) {
                   //把两个字符串都拆分成字符数组
                       char v1[] = value;
                       char v2[] = anotherString.value;
                       int i = 0;
                       //循环对比两个字符串中的每一个字符是否相等
                       while (n-- != 0) {
                           //如果其中一个字符串不相等，就直接返回false
                           if (v1[i] != v2[i])
                               return false;
                           i++;
                       }
                       return true;
                   }
               }
               return false;
           }
      String类型重写了Object的equals方法 在判断的时候需要传递一个Object类型的参数
      在比较的时候 会先通过 instanceof 判断是否为String类型
      * equalsIgnoreCase()  忽略大小写

      3.compareTo()  字符串  比较
          public int compareTo(String anotherString) {
              int len1 = value.length;
              int len2 = anotherString.value.length;
              //获取到两者之间长度短的 int值
              int lim = Math.min(len1, len2);
              //把两个字符串都拆分成字符数组
              char v1[] = value;
              char v2[] = anotherString.value;

              int k = 0;
              //对比每一个字符
              while (k < lim) {
                  char c1 = v1[k];
                  char c2 = v2[k];
                  if (c1 != c2) {
                      //又字符不相等就返回差值
                      return c1 - c2;
                  }
                  k++;
              }
              return len1 - len2;
          }
          * compareToIgnoreCase()  忽略大小写


          equals  compareTo
          equals可以接受Object类型的参数，compareTo 只能接受String类型
          equals返回值为Boolean    compareTo 返回值为int
          两种都能判断字符串相等与否  判断相等的依据
          equals  true        compareTo   0

      4.其他重要方法
         indexOf()        查询字符串首次出现的下标位置
         lastIndexOf()    查询字符串最后出现的下标位置
         contains()       查询字符串中是否包含另外一个字符串
         toLowerCase()    转小写
         toUpperCase()    转大写
         length()         字符串长度
         trim()           去掉字符串首尾的空格
         replace()        替换掉字符串中的某个字符
         split()          把字符串拆分成数组
         join()           把字符串数组转为字符串


      & 1.为什么String类型要用final?
            1.1 final修饰的类不能被继承   （值是不能被修改的）反射
            如果在传参的时候 不需要考虑谁会修改它的值
            1.2 安全
            1.3 高效  字符串常量池可以为我们提供缓存字符串，提高程序的运行效率
        2.== 和 equals 区别是什么?
           ==对于基本数据类型 比较的是“值” 看看值是否相等
           对于  引用类型       比较的是引用地址是否相同

            Object中  equals 方法其实就是==
            String重写equals 方法把它修改成两个字符串的值是否相等

        String   StringBuilder  StringBuffer有什么区别
         String                 不可变类  所以每次拼接使用String的话 性能会很低  (性能差)
          StringBuffer        (安全性高，性能一般)
                     synchronized    来保持线程安全  提供了  append  和  insert方法进行拼接
          @Override
             public synchronized StringBuffer append(Object obj) {
                 toStringCache = null;
                 super.append(String.valueOf(obj));
                 return this;
             }

             @Override
             public synchronized StringBuffer append(String str) {
                 toStringCache = null;
                 super.append(str);
                 return this;
             }
         StringBuilder  从JDK1.5  出现   (性能高，安全差) 在非并发环境下优先使用
         append  insert
          public AbstractStringBuilder append(Object obj) {
                 return append(String.valueOf(obj));5
             }

        String的 intern()方法有什么含义
        String类型 在  JVM中 如何存储的？编译器又对String做了哪些优化呢？
         String常见的创建方式   new String();  直接赋值
         直接赋值的方式会向常量池中查找是否存在这个值  如果存在，就把引用地址指向此值
         否则会先在常量池中创建 然后再打引用指向此值
         JDK1.7之后 把永生代换成元空间，把字符串常量池从方法区转移到了Java堆上

      优化
                String s1="Ja"+"va";    在JVM中编译过程会直接把当前的"Ja"+"va" 转换成 "Java"
                String s2="Java";
                System.out.println(s1==s2);  true

2.线程的状态有哪些？它是如何工作的？
   线程(Thread) 是并发编程的基础，也是程序执行的最小单元，它依托进程而存在。一个进程可以包含多个线程。
   多线程可以共享一块内存和一组系统资源，因此线程之间的切换更加节省资源、更加轻量化，（轻量级进程）

   JDK1.5之后 以枚举的类型定义在Thread源码中   6个状态

   1.  NEW
        新建状态  线程被创建出来，没有启动的时候
   2.  RUNNABLE
        就绪状态  表示可以运行的线程状态，它可能正在运行，或者排队等待CPU分配资源运行
   3.  BLOCKED
        阻塞等待锁的线程状态
        (阻塞状态)
        表示处于阻塞状态的线程正在等待监视器锁， 比如等待执行 synchronized 代码块或者 synchronized 标记的方法
   4.  WAITING
        等待状态 一个处于等待状态的线程正在等待另一个线程执行某个特定动作
        Object.wait();    其他线程调用  Object.notify() 或者  Object.notifyAll()
   5.  TIMED_WAITING
        计时等待状态  和等待状态类似，多设置了超时时间
        Object.wait(long timeout);     Thread.join(long timeout)
   6.  TERMINATED4
        终止状态 表示线程已经执行完成

   线程的工作模式：
       1.首先先创建线程并指定需要执行的方法，然后调用线程的 start()方法,此时线程就从NEW=>RUNNABLE
       2.线程会判断要执行的方法中有没有synchronized同步代码块，如果有并且其他线程也在使用，那么线程会变为BLOCKED
       3.当其他线程使用完这个锁之后，线程会继续执行剩余的方法
       4.当遇到Object.wait()  或者 Thread.join() 方法时，线程会变为WAITING，若果时带了超时时间的方法 那么会进入
       TIMED_WAITING，当其他线程执行了Object.notify() 或者  Object.notifyAll()，线程会被唤醒继续执行剩余的方法
       直到方法全部执行完毕，最后进入TERMINATED


   BLOCKED 和 WAITING 有什么区别?
   start()方法和run()有什么区别?
   线程的优先级有什么用？怎么设置？

   线程的常用方法有哪些？
   1.join()
     在一个线程中调用other.join()，这时当前线程会让出执行权给other线程，知道other线程执行完毕，或者过了超时时间，然后在运行当前线程
     public final synchronized void join(long millis)
        throws InterruptedException {
            long base = System.currentTimeMillis();
            long now = 0;
            //超时时间不能小于 0
            if (millis < 0) {
                throw new IllegalArgumentException("timeout value is negative");
            }
            //0 代表无限等待
            if (millis == 0) {

                while (isAlive()) {
                    wait(0);
                }
            } else {
                while (isAlive()) {
                    long delay = millis - now;
                    if (delay <= 0) {
                        break;
                    }
                    wait(delay);
                    now = System.currentTimeMillis() - base;
                }
            }
        }

     yield()   本地方法   C 或者C++实现的
         public static native void yield();
         该方法表示给线程调度器一个当前线程愿意让出CPU使用权的暗示，但是线程调度器可能会忽略这个暗示
         使用这个方法可能每次执行的结果都不一样，这是因为这个方法非常不稳定，线程调度器不一定会采纳yield出让CPU资源的建议



   谈谈你对锁的理解？  如何动态模拟一个死锁？
      并发编程中 两个重要概念  线程  和  锁
      多线程是把双刃剑  提高程序性能的同时，也带来了编码的复杂性，对开发者的要求也提了一个档次
    锁的出现就是为了保证多线程在同时操作一组资源时的一致性，当我们给资源加上所之后，只有拥有这个
    锁的线程才能操作当前资源，其他线程只能排队。

    死锁：两个线程同时占用两个资源，又想要使用对方的资源，由于锁的关系 不得不等待对方把资源释放 的互相僵持状态
         线程一         线程二
          拥有           拥有

          锁A            锁B
     我们使用线程一拥有锁lock1的同时  试图获取lock2  而线程二拥有lock2同时试图获取lock1
     这样会造成两方都在等对面释放资源，然后就造成了死锁

        锁是指在并发编程中，当有多个线程同时操作一个资源时，为了保证数据操作的正确性，我们需要让多线程
     排队一个一个的操作这个资源，而这个过程就是给资源 加锁  释放锁的过程

   1.悲观锁 和 乐观锁
      悲观锁指的是 数据对外界的修改采用保守策略，认位线程很容易修改数据的值，因此在整个数据被修改的过程中
      会采用锁定状态，直到一个线程使用完，其他线程才可以使用
Compiled from "LockExample.java"
public class com.lagou.interview.ext.LockExample {
  public com.lagou.interview.ext.LockExample();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return
 
  public static void main(java.lang.String[]);
    Code:
       0: ldc           #2                  // class com/lagou/interview/ext/LockExample
       2: dup
       3: astore_1
       4: monitorenter // 加锁
       5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
       8: ldc           #4                  // String lock
      10: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      13: aload_1
      14: monitorexit // 释放锁
      15: goto          23
      18: astore_2
      19: aload_1
      20: monitorexit
      21: aload_2
      22: athrow
      23: return
    Exception table:
       from    to  target type
           5    15    18   any
          18    21    18   any
}

    被synchronized修饰的代码块  在执行之前先使用 monitorenter指令加锁，执行结束之后 通过指令monitorexit 解锁，整个过程中
    执行的代码都是被锁定的状态，这个就是悲观锁实现的流程

    乐观锁和悲观锁的概念相反，乐观锁任务一般情况下数据在修改时不会出现冲突，所以在数据访问之前不会加锁，但是会在数据提交更改时
    对数据进行检测
    Java 乐观锁  CAS    Compare And Swap  比较并交换      ABA问题 （解决ABA问题  版本号stamp  每次比较时不仅仅之比较当前值，还比较版本号）
                                                          线程拿到了最初的值A  然而将要进行CAS的时候 被其他线程抢占了执行权
                                                          ，把此值改为B，然后其他线程又把此值从B变成了A，但是此时的A已经不是原来的A值了
                                                          但时最原始的线程并不知道这个情况，在进行CAS的时候，就只对比了原来的初始值A就进行了修改

     乐观锁有一个优点：因为是提交的时候才进行锁定的  因此不会造成线程死锁


   2.它们的应用有哪些  乐观锁有什么问题？
   3.什么时可重入锁  用代码怎么实现  实现的原理
   4.什么是共享锁  什么是独占锁










